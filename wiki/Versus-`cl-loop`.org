* How does it compare to =cl-loop=?
  :PROPERTIES:
  :CUSTOM_ID: how-does-it-compare-to-other-approaches
  :END:

  =loopy= should be comparable with =cl-loop= for most things, keeping in
  mind the following:
  - It is probably less efficient than =cl-loop=, though I am so far trying to
    keep the same logic that =cl-loop= uses.
  - It has more flexible control-flow commands, under which you can easily group
    sub-commands, including assignments.
  - It has a =skip= command to skip the rest of the loop body and immediately
    start the next iteration.  Of course, a similar effect could be achieved
    using the =when= or =unless= commands.

  =loopy= is not always one-to-one replacement for =cl-loop=, but it is easy to
  use and extend, and performs well in the cases that it already handles.

  Below is a simple example of =loopy= vs =cl-loop=.

  #+BEGIN_SRC emacs-lisp
    (require 'cl-lib)
    (cl-loop with some-thing = 5
             for i from 1 to 100
             do (message "I is %s" i)
             when (> (+ i 5) 20)
             return (format "Done: %d" i))

    (require 'loopy)
    (loopy (with (some-thing 5))
           ((list i (number-sequence 1 100))
            (do (message "I is %s" i))
            (when (> (+ i 5) 20)
              (return (format "Done: %d" i)))))
  #+END_SRC

  The main benefit (I believe) of Loopy is clearer grouping of commands under
  conditionals while still using a clean syntax, such as in the below example.

  #+BEGIN_SRC emacs-lisp
    ;; => '((2 4) (4 8) (6 12) (8 16) (10 20))
    (loopy ((list i (number-sequence 1 10))
            (when (cl-evenp i)
              (expr once i)
              (expr twice (* 2 i))
              (collect together (list once twice))))
           (finally-return together))
  #+END_SRC

  In my experience, =cl-loop= does not allow the easy grouping of assignment
  statements under a =when= condition.  For example, below is something I would
  like to try to do with =cl-loop=.

  I am aware that in this example the =for= statements aren't necessary and that
  the =collect= statements would be sufficient, but (when I come across things
  like this in my work) I would like to use them to declare variables for
  readability purposes.

  #+BEGIN_SRC emacs-lisp
    (require 'cl-lib)
    (save-match-data
      (cl-loop with pattern = "^Line\\([[:digit:]]\\)-Data\\([[:digit:]]\\)"
               for line in (split-string "Line1-Data1\nBad\nLine2-Data2")
               when (string-match pattern line)
               for line-num = (concat "L" (match-string 1 line))
               and for data-num = (concat "D" (match-string 2 line))

               ;; … Further processing now that data is named …

               and collect line-num into line-nums
               and collect data-num into data-nums
               finally return (list line-nums data-nums)))

    ;; Normal Elisp:
    (save-match-data
      (let ((pattern "^Line\\([[:digit:]]\\)-Data\\([[:digit:]]\\)")
            (line-nums)
            (data-nums))
        (dolist (line (split-string "Line1-Data1\nBad\nLine2-Data2"))
          (when (string-match pattern line)
            (let ((line-num (concat "L" (match-string 1 line)))
                  (datum-num (concat "D" (match-string 2 line))))

              ;; … Further processing now that data is named …

              (push line-num line-nums)
              (push datum-num data-nums))))
        (list (nreverse line-nums) (nreverse data-nums))))
  #+END_SRC

  Here is how one could currently do it with =loopy=:

  #+BEGIN_SRC emacs-lisp
    (require 'loopy)
    (save-match-data
      (loopy (with (pattern "^Line\\([[:digit:]]\\)-Data\\([[:digit:]]\\)"))
             ((list line (split-string "Line1-Data1\nBad\nLine2-Data2"))
              (when (string-match pattern line)
                (expr line-num (concat "L" (match-string 1 line)))
                (expr datum-num (concat "D" (match-string 2 line)))

                ;; … Further processing now that data is named …

                (collect line-nums line-num)
                (collect data-nums datum-num)))
             (finally-return line-nums data-nums)))
  #+END_SRC

  I believe that the value of the macro increases for longer loop bodies with
  several conditional commands.

  Another nice ability, one that I'm not sure =cl-loop= has, is a specific
  command for skipping/continuing a loop iteration.  Of course, one could also
  re-organize code under a conditional command like =when= to achieve the same
  effect.

  #+BEGIN_SRC emacs-lisp
    ;; Returns even numbers that aren't multiples of 10.
    (loopy ((list i (number-sequence 1 20))
            (when (zerop (mod i 10))
              (skip))
            (when (cl-evenp i)
              (push-into my-collection i)))
           (finally-return (nreverse my-collection))) ; => (2 4 6 8 12 14 16 18)
  #+END_SRC

** Translating from =cl-loop=
   :PROPERTIES:
   :CUSTOM_ID: translating-from-cl-loop
   :END:

*** For Clauses
    :PROPERTIES:
    :CUSTOM_ID: for-clauses
    :END:

    As Emacs has many functions that return lists, there is no need to implement
    an exact equivalent for every =for=-clause that =cl-loop= has.  Instead, one
    can just iterate through the return value of the appropriate function using
    the =list= command.

    | =cl-loop=                                     | =loopy=                                          |
    |-----------------------------------------------+--------------------------------------------------|
    | =for VAR from EXPR1 to EXPR2 by EXPR3=        | =(list VAR (number-sequence EXPR1 EXPR2 EXPR3))= |
    | =for VAR in LIST [by FUNCTION]=               | =(list VAR LIST [FUNC])=                         |
    | =for VAR on LIST [by FUNCTION]=               | =(cons VAR VAL [FUNC])=                          |
    | =for VAR in-ref LIST by FUNCTION=             | =(list-ref VAR LIST [FUNC])=                     |
    | =for VAR across ARRAY=                        | =(array VAR ARRAY)=                              |
    | =for VAR across-ref ARRAY=                    | =(array-ref VAR ARRAY)=                          |
    | =for VAR being the elements of SEQUENCE=      | =(seq VAR SEQUENCE)=                             |
    | =for VAR being the elements of-ref SEQUENCE=  | =(seq-ref VAR SEQUENCE)=                         |
    | =for VAR being the symbols [of OBARRAY]=      | None so far.  Use ~mapatoms~.                    |
    | =for VAR being the hash-keys of HASH-TABLE=   | =(list VAR (hash-table-keys HASH-TABLE))=        |
    | =for VAR being the hash-values of HASH-TABLE= | =(list VAR (hash-table-values HASH-TABLE))=      |
    | =for VAR being the key-codes of KEYMAP=       | None so far.  Use ~map-keymap~.                  |
    | =for VAR being the key-bindings of KEYMAP=    | None so far.  Use ~map-keymap~.                  |
    | =for VAR being the key-seqs of KEYMAP=        | None so far.                                     |
    | =for VAR being the overlays [of BUFFER]=      | None so far.  Use ~overlay-lists~.               |
    | =for VAR being the intervals [of BUFFER]=     | None so far.                                     |
    | =for VAR being the frames=                    | =(list VAR (frame-list))=                        |
    | =for VAR being the windows [of FRAME]=        | =(list VAR (window-list FRAME))=                 |
    | =for VAR being the buffers=                   | =(list VAR (buffer-list))=                       |
    | =for VAR = EXPR1 then EXPR2=                  | =(expr VAR EXPR1 EXPR2)=                         |

*** Iteration Clauses
    :PROPERTIES:
    :CUSTOM_ID: iteration-clauses
    :END:

    | =cl-loop=          | =loopy=                      |
    |--------------------+------------------------------|
    | =repeat INT=       | =(repeat INT)=               |
    | =while COND=       | =(unless COND (return nil))= |
    | =until COND=       | =(when COND (return nil))=   |
    | =iter-by iterator= | None so far.                 |

    The clauses =always=, =never=, and =thereis= can be replaced by a
    combination of an exiting command and the =after-do= (also written
    =else-do=) macro argument.  Below is an example from the CL Lib manual.

    #+BEGIN_SRC emacs-lisp
      ;; With `cl-loop':
      (if (cl-loop for size in size-list always (> size 10))
          (only-big-sizes)
        (some-small-sizes))

      ;; With `loopy':
      ;; Depends on whether the functions have return values.
      (loopy ((list size size-list)
              ;; `return` is just a wrapper for `cl-return`.
              (when (< size 10) (return (some-small-sizes))))
             ;; Only runs if loop doesn't exit early.
             (else-do (cl-return (only-big-sizes))))
    #+END_SRC

    A seen in the above example, =loopy= does not always have a one-to-one
    translation to =cl-loop= ([[#a-slightly-more-complicated-example][though you could try a custom command]]).

    It is not an explicit goal to be able to replace all uses of =cl-loop= with
    =loopy=.  I'd prefer that =loopy= be useful in places where =cl-loop= might
    not be enough, instead of forcing =loopy= into places where =cl-loop=
    already works well.

    Other options in the above example include using =cl-every=,
    =seq-every-p=, Dash’s =-all?=, etc.

*** Accumulation Clauses
    :PROPERTIES:
    :CUSTOM_ID: accumulation-clauses
    :END:

    In =loopy=, when accumulation commands are not given a =VAR=, they
    accumulate into different variables.  If you want accumulations to act on
    the same variable, you must give the same =VAR=.

    | =cl-loop=                | =loopy=              |
    |--------------------------+----------------------|
    | =append EXPR into VAR=   | =(append VAR EXPR)=  |
    | =collect EXPR into VAR=  | =(collect VAR EXPR)= |
    | =concat EXPR into VAR=   | =(concat VAR EXPR)=  |
    | =count EXPR into VAR=    | =(count VAR EXPR)=   |
    | =maximize EXPR into VAR= | =(max VAR EXPR)=     |
    | =minimize EXPR into VAR= | =(min VAR EXPR)=     |
    | =nconc EXPR into VAR=    | =(nconc VAR EXPR)=   |
    | =sum EXPR into VAR=      | =(sum VAR EXPR)=     |
    | =vconcat EXPR into VAR=  | =(vconcat VAR EXPR)= |

*** Other Clauses
    :PROPERTIES:
    :CUSTOM_ID: other-clauses
    :END:

    In =loopy=, =if=, =when=, and =unless= can take multiple loop commands as
    arguments, and operate more like their Lisp counterparts.

    This means that =if= is not a synonym for =when=.  Just like the normal Lisp
    special form =if=, =(if COND cmd1 cmd2 cmd3)= only runs =cmd1= if =COND=
    evaluates to non-nil, and only runs commands =cmd2= and =cmd3= if =COND=
    evaluates to =nil=.

    =loopy= also provides the command =cond=, which works like the normal Lisp
    special form =cond=.

    | =cl-loop=              | =loopy=                                     |
    |------------------------+---------------------------------------------|
    | =with var = value=     | =(with (VAR VALUE))= as a macro argument    |
    | =if COND clause=       | =(if COND CMDS)= as a loop command          |
    | =when COND clause=     | =(when COND CMDS)= as a loop command        |
    | =unless COND clause=   | =(unless COND CMDS)= as a loop command      |
    | =named NAME=           | =NAME= as a macro argument                  |
    | =initially [do] EXPRS= | =(before-do EXPRS)= as a macro argument     |
    | =finally [do] EXPRS=   | =(finally-do EXPRS)= as a macro argument    |
    | =finally return EXPR=  | =(finally-return EXPR)= as a macro argument |
    | =do EXPRS=             | =(do EXPRS)= as a loop command              |
    | =return EXPR=          | =(return EXPR)= as a loop command           |

