#+title: Loopy: A Looping and Iteration Macro
#+author: Earl Hyatt
#+export_file_name: loopy

# Make sure to export all headings as such.  Otherwise, some links to
# sub-headings won’t work.
#+options: H:6
# Some parsers require this option to export footnotes.
#+options: f:t

=loopy= is a macro meant for iterating and looping.  It is similar in usage to
=cl-loop= [fn:cl-loop] but uses symbolic expressions rather than keywords.

=loopy= should be complementary to the features provided by the Seq [fn:seq] and
CL [fn:cl-lib] libraries (including =cl-loop=) and Emacs's regular looping and
mapping features.

-----
#+begin_center
*NOTE*: Loopy is still in its early stages.\\
Constructive criticism is welcome.  If you see a place for improvement,
please let me know.
#+end_center
-----

# This auto-generated by toc-org.
* Table of Contents                                                :TOC:noexport:
- [[#introduction][Introduction]]
- [[#how-to-use][How to use]]
  - [[#macro-arguments][Macro Arguments]]
  - [[#loop-commands][Loop Commands]]
- [[#adding-custom-commands][Adding Custom Commands]]
- [[#comparing-to-cl-loop][Comparing to =cl-loop=]]
-  [[#real-world-examples][Real-World Examples]]
- [[#footnotes][Footnotes]]

* Introduction

  The =loopy= macro has several possible arguments, each beginning with a
  keyword.

  - =with= declares variables that are bound in order before and around the
    loop, like in a =let*= binding.
  - =before-do= is a list of normal Lisp expressions to run before the loop
    executes.
  - =loop= is a list of special commands that create the loop body.  These
    commands are described in detail in the section [[#loop-commands][Loop Commands]].
  - =after-do= is a list of normal Lisp expressions to run after the successful
    completion of the loop.
  - =finally-do= is a list of normal Lisp expressions that always run,
    regardless of whether an early return was triggered in the loop body.
  - =finally-return= is an expression whose value is always returned, regardless
    of whether an early return was triggered in the loop body.

  The loop commands generally follow the form =(COMMAND VARIABLE-NAME &rest ARGS)=.
  For example,

  - To iterate through a sequence [fn:sequence], use =(seq elem [1 2 3])= (for
    efficiency, there are also more specific commands, like =list=).
  - To collect values into a list, use =(collect my-collection collected-value)=.
  - To just bind a variable to the result of a Lisp expression, use
    =(expr my-var (my-func))=

  Below is a full example of the arguments of the =loopy= macro.  The top-level
  forms have a flexible-order, but meaning is clearest if they have the
  following order.  All of the arguments are technically optional, but having a
  loop without a body wouldn't be useful.

  #+BEGIN_SRC emacs-lisp
    ;; Returns: '((2 4 6 8 10) (1 3 5 7 9)) and prints messages.
    (loopy
     ;; Name the loop `my-loop'.
     my-loop
     ;; Create the locally scoped variable `success-p', initialized to `nil'.
     (with (success-p nil))
     ;; Before starting the loop, print a message.
     (before-do (message "Beginning loop ..."))
     ;; Create the loop body.
     (loop (list i (number-sequence 1 10))        ; Assign `i' from 1 through 10.
           (do (message "Checking number: %d" i)) ; Report the value of `i'.
           (if (cl-evenp i)                       ; If `i' is even, add to the list
               (collect found-evens i)            ; of even numbers, otherwise add
             (collect found-odds i)))             ; to the list of odd numbers.
     ;; If the loop completes successfully, print a message and update `success-p'.
     (after-do (message "Loop completed successfully.")
               (setq success-p t))
     ;; Always report based on the value of `success-p', and message the value of
     ;; the lists of even and odd numbers.
     (finally-do (if success-p
                     (message "Confirmed success reported.")
                   (message "W: Success not confirmed!"))
                 (message "Found evens: %s" found-evens)
                 (message "Found odds: %s" found-odds))
     ;; Always return a list containing the list of even numbers and the list of odd
     ;; numbers.
     (finally-return (list found-evens found-odds)))
  #+END_SRC

  Loopy is not the only Lisp library that uses expressions instead of keyword
  clauses (like in =cl-loop=).  [[https://common-lisp.net/project/iterate/][=iterate=]] and [[https://github.com/Shinmera/for/][=for=]] are two examples in Common
  Lisp.  I know of no examples for Emacs Lisp.

  Though I am not familiar with either, it seems to me that the =loopy= macro is
  more like =for= than it is like =iterate=.  I suspect that, given it’s youth,
  Loopy is much simpler than both.

  #+begin_src emacs-lisp
    ;; Collecting 10 random numbers:
    ;; cl-loop, iterate, for, loopy

    (cl-loop repeat 10 collect (random 10))

    (iterate (repeat 10) (collect (random 10)))

    (for:for ((i repeat 10) (randoms collecting (random 10))))

    (loopy ((repeat 10) (collect (random 10))))
  #+end_src

  Generally, I’d expect that all of the packages handle basic use cases in
  similar ways.  While =iterate= can apparently embed its looping constructs in
  arbitrary code, =loopy= doesn’t allow that, and I believe that the same is
  true of =for=.

  However, Loopy is not yet feature complete.  Please request features or report
  problems in this project’s [[https://github.com/okamsn/loopy/issues][issues tracker]].  While most things are covered,
  full feature parity with =cl-loop= is still being worked on.

* How to Install                                                   :noexport:
  Currently, Loopy must be installed manually.  Here is how one could use
  ~straight.el~ with ~use-package~

  #+begin_src emacs-lisp
    (use-package loopy
      :straight (loopy :type git :host github :repo "okamsn/loopy"))
  #+end_src

* How to use
  :PROPERTIES:
  :CUSTOM_ID: how-to-use
  :END:

  Macro arguments set up the lexical environment the loop runs in, Lisp code
  that runs before or after the loop, and the ultimate return value of the
  macro.  See the section [[#macro-arguments][Macro Arguments]].

  “Loop commands” are the main feature of the =loopy= macro and make up the
  =loop= macro argument, such as =list= in =(list i '(1 2 3))=.  A command
  inserts code into the loop body, but can also perform additional setup, such
  as initializing specified or implicit variables.  Many commands set up a
  condition for ending the loop.  See the section [[#loop-commands][Loop Commands]].

  The loop ends when any condition required by a loop command evaluates to
  false.  If no conditions are needed, the loop runs infinitely until a =return=
  or =return-from= command is reached.  See the section [[#exiting-the-loop-early][Exiting the Loop Early]].

  Except when using [[#accumulation-commands][accumulating loop commands]], return values must be stated
  explicitly, either as an early return in the loop body via the =return= or
  =return-from= commands, or as part of the =finally-return= macro argument.
  =nil= is returned by default.

** Macro Arguments
   :PROPERTIES:
   :CUSTOM_ID: macro-arguments
   :END:

   =loopy= takes at most 7 arguments, which are all technically optional.
   Calling the =loopy= macro without arguments creates an infinite loop that
   does nothing.

   You can name a loop by passing =loopy= an unquoted symbol.  All other
   arguments are expressions that begin with a keyword from the table below.
   For clarity and convenience, some keywords have multiple names and the =loop=
   keyword can be excluded.

   | Keyword                                | Usage                                                   |
   |----------------------------------------+---------------------------------------------------------|
   | =with=, =let*=                         | Declare variables before the loop.                      |
   | =before-do=, =before=                  | Run Lisp expressions before loop starts.                |
   | =loop=, or excluded                    | Add expressions to the loop body and perform setup.     |
   | =after-do=, =after=, =else-do=, =else= | Run Lisp expressions after loop successfully completes. |
   | =finally-do=, =finally=                | Always run Lisp expressions after loop exits.           |
   | =finally-return=, =return=             | Return a value, regardless of how the loop completes.   |

   The loop body and any expressions that are part of the =before-do= and
   =after-do= arguments are contained in a single =cl-block=.  Naming the loop
   really just names the block, allowing for more specific exiting via
   ~cl-return~ and the loop commands that wrap it.

   Finally, =(finally-return 1 2 3)= is the same as =(finally-return (list 1 2
   3))=.  This is convenient when using ~seq-let~, ~pcase-let~,
   ~cl-destructuring-bind~, and the like.

** Loop Commands
   :PROPERTIES:
   :CUSTOM_ID: loop-commands
   :END:

   Loop commands are the main feature of the macro.  There are commands for
   iterating through lists, arrays, and sequences; for accumulating values into
   new sequences; for conditionally running commands; for breaking from the loop
   or returning early with a chosen value; and others.

   These commands can use destructuring, even accumulation commands. Some
   commands create ~setf~-able places.

   For convenience, and like in ~cl-loop~, accumulation commands have an implied
   return value and don’t require specifying a variable in which to accumulate a
   value.

   Below are a few basic examples.  The entire list of commands can be read at
   the section [[file:~/Projects/elisp-loopy/doc/loopy.org::#loop-commands][Loop Commands]] in the documentation.

    #+begin_src emacs-lisp
      ;; Note that `my-collection' is the first value in the implied return,
      ;; even though the collection happens after the first summation step.
      ;;
      ;; => (((4 5 6)) 5 7 9), for `my-collection', `sum1', `sum2', `sum3'
      (loopy ((list elem '((1 2 3) (4 5 6)))
              (when (equal elem '(4 5 6))
                (collect my-collection elem))
              (sum (my-sum1 my-sum2 my-sum3) elem)))

      ;; => ((1 22))
      (loopy (with (my-list '((1 2 3))))
             ((list-ref (_ . j) my-list)
              (do (setf j '(22))))
             (return my-list))

      (loopy ((repeat 5)
              (expr i 1 2 3)
              (collect coll i))
             (return coll)) ; => '(1 2 3 3 3)

      ;; => '((2 4 6) (1 3 5) ("cat" "dog"))
      (loopy ((list i '(1 2 3 "cat" 4 5 6 "dog"))
              (cond
               ((not (numberp i)) (collect not-numbers i))
               ((cl-evenp i)      (collect evens i))
               (t                 (collect odds i))))
             (return evens odds not-numbers))

      ;; => 'bad-val?
      (loopy outer-loop
             ((list inner-list '((1 2 3) (1 bad-val? 1) (4 5 6)))
              (do (loopy ((list i inner-list)
                          (when (eq i 'bad-val?)
                            (return-from outer-loop 'bad-val?)))))))
    #+end_src

* Adding Custom Commands
  :PROPERTIES:
  :CUSTOM_ID: adding-custom-commands
  :END:

   The core working of =loopy= is taking a command and generating code that is
   substituted into or around a loop body.

   For example, parsing the command =(list i '(1 2 3))= produces the following
   list of instructions.  Some commands require the creation of unique temporary
   variables, such as =g3019= in the below output. Such variables are called
   “implicit", as opposed to the explicitly named variable =i= in the command.

   #+BEGIN_SRC emacs-lisp
     ((loopy--implicit-vars g3019 '(1 2 3))
      (loopy--explicit-vars i nil)
      (loopy--pre-conditions consp g3019)
      (loopy--main-body setq i (car g3019))
      (loopy--latter-body setq g3019 (cdr g3019)))
   #+END_SRC

   The ~car~ of an instruction is the place to put code and the ~cdr~ of the
   instruction is said code to put.  You can see that not all of the code to be
   inserted is a valid Lisp form.  Instead of being evaluated as an expression,
   some instructions insert pairs of names and values into variable lists like
   in ~let~ and ~let*~ .

   | Place                     | Code                         |
   |---------------------------+------------------------------|
   | =loopy--implicit-vars=    | =(g3019 '(1 2 3))=           |
   | =loopy--explicit-vars=    | =(i nil)=                    |
   | =loopy--pre-conditions=   | =(consp g3019)=              |
   | =loopy--main-body=        | =(setq i (car g3019))=       |
   | =loopy--latter-body=      | =(setq g3019 (cdr g3019))=   |

   Commands are parsed by =loopy--parse-body-forms=, which receives a list of
   commands and returns a list of instructions.  For commands that take
   sub-commands as arguments (such as =cond=, =if=, and =when=), more specific
   parsing functions are called in a mutually recursive fashion (e.g.,
   Function-1 uses Function-2 which uses Function-1, and so on).

   For example, consider the function =loopy--parse-conditional-forms=, which
   parses the =if=, =when=, and =unless= commands.  It needs to be able to group
   any code going to the loop body under its respective conditional control
   structure.  To do this, it uses =loopy--parse-body-forms= to turn its
   sub-commands into a list of instructions, and then checks the =car= of each
   instruction.

   #+BEGIN_SRC emacs-lisp
     (defun loopy--parse-conditional-forms (wrapper condition forms &optional loop-name)
       "Parse FORMS, wrapping `loopy--main-body' expressions in a conditional form.
     The instructions (e.g., return expressions) are wrapped with a
     WRAPPER with CONDITION.  Optionally needs LOOP-NAME for block
     returns."
       (let ((full-instructions)
             (sub-instructions (loopy--parse-body-forms forms loop-name))
             (conditional-body))
         (dolist (instruction sub-instructions)
           (cl-case (car instruction)
             (loopy--main-body (push (cdr instruction) conditional-body))
             (t                (push instruction full-instructions))))
         (push `(loopy--main-body . (,wrapper ,condition ,@conditional-body))
               full-instructions)
         full-instructions))
   #+END_SRC

   The hardest part of this exchange is making sure the inserted code ends up in
   the correct order.

   A loop body command has 7 main places to put code:

   - =loopy--explicit-generalized-vars= :: Lists of a symbol and a macro
     expansion that will be given to =cl-symbol-macrolet=.  This is used to
     create named ~setf~-able places.  The expansion you use depends on the kind
     of sequence and how the it is updated.

     For example, =(list-ref i my-list)= declares =i= to be a symbol which
     expands to =(car TEMP-VAR)=, in which =TEMP-VAR= holds the value of
     =my-list=.  At the end of the loop body, =TEMP-VAR= is set to its =cdr=,
     ensuring that the next call to =car= returns the correct value.

   - =loopy--implicit-vars= :: Lists of a symbol and an expression that will be
     given to =let=.  This is used for creating variables that are not named but
     must exist, such as for holding ='(1 2 3)= in =(list i '(1 2 3))=.

   - =loopy--explicit-vars= :: Lists of a symbol and an expression that will be
     given to =let=.  This is needed to ensure that variables explicitly named
     in commands are locally scoped, such as the =i= in =(list i '(1 2 3))=.

   - =loopy--pre-conditions= :: Expressions that determine if the =while=
     loop runs/continues, such as whether a list still has elements in it.
     If there is more than one expression, than all expressions are used in
     an =and= special form.

   - =loopy--main-body= :: Expressions that make up the main body of the
     loop.

   - =loopy--latter-body= :: Expressions that need to be run after the main
     body, such as updating implicit variables.

   - =loopy--post-conditions= :: Expressions that determine whether the
     =while= loop continues, but checked after the loop body has run.  The
     code from this is ultimately appended to the latter body before being
     substituted in.

   There are 5 more variables a loop command can push to, but they are derived
   from the macro's arguments.  Adding to them after using a macro argument
   might lead to unintended behavior.  You might wish to use them if, for
   example, you are concerned with what happens after the loop exits/completes.

   - =loopy--with-vars= :: Lists of a symbol and an expression that will be
     given to =let*=.  These are derived from the =with= macro argument.

   - =loopy--before-do= :: Expressions to evaluate before the loop.  These are
     derived from the =before-do= macro argument.

   - =loopy--after-do= :: Expressions to evaluate after the loop completes
     successfully.  These are derived from the =after-do= macro argument.

   - =loopy--final-do= :: Expressions to evaluate after the loop completes,
     regardless of success.  These are derived from the =finally-do= macro
     argument.

   - =loopy--final-return= :: An expression that is always returned by the
     macro, regardless of any early returns in the loop body.  This is
     derived from the =finally-return= macro argument.

   The structure of the macro’s expanded code depends on the features used
   (e.g., =loopy= won’t try to declare variables if none exist), but the result
   will work similar to the below example.

   #+BEGIN_SRC emacs-lisp
     `(cl-symbol-macrolet ,loopy--explicit-generalized-vars
        (let* ,loopy--with-vars
          (let ,(append loopy--implicit-vars loopy--explicit-vars)
            (let ((loopy--early-return-capture
                   (cl-block ,loopy--name-arg
                     ,@loopy--before-do
                     (while ,(cl-case (length loopy--pre-conditions)
                               (0 t)
                               (1 (car loopy--pre-conditions))
                               (t (cons 'and loopy--pre-conditions)))
                       (cl-tagbody
                        ,@loopy--main-body
                        loopy--continue-tag
                        ,@loopy--latter-body))
                     ,@loopy--after-do
                     nil)))
              ,@loopy--final-do
              ,(if loopy--final-return
                   loopy--final-return
                 'loopy--early-return-capture)))))
   #+END_SRC

   For more on custom commands, see the wiki page [[https://github.com/okamsn/loopy/wiki/Custom-Commands][Custom Commands]].

* Comparing to =cl-loop=
  :PROPERTIES:
  :CUSTOM_ID: how-does-it-compare-to-other-approaches
  :END:

  See the wiki page [[https://github.com/okamsn/loopy/wiki/Versus-%60cl-loop%60][Versus =cl-loop=]].


*  Real-World Examples

  See the wiki page [[https://github.com/okamsn/loopy/wiki/Examples][Examples]].

* Footnotes

[fn:cl-loop]
[[https://www.gnu.org/software/emacs/manual/html_node/cl/Loop-Facility.html#Loop-Facility]]

[fn:seq]
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Sequence-Functions.html]],
[[info:elisp#Sequence Functions]]

[fn:cl-lib]
[[https://www.gnu.org/software/emacs/manual/html_node/cl/index.html]], [[info:cl]]

[fn:sequence]
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Sequences-Arrays-Vectors.html]],
[[info:elisp#Sequences Arrays Vectors]]
