#+title: Loopy: A Looping and Iteration Macro
#+author: Earl Hyatt
#+export_file_name: loopy

# Make sure to export all headings as such.  Otherwise, some links to
# sub-headings won’t work.
#+options: H:6
# Some parsers require this option to export footnotes.
#+options: f:t

=loopy= is a macro meant for iterating and looping.  It is similar in usage to
=cl-loop= [fn:cl-loop] but uses symbolic expressions rather than keywords.

=loopy= should be complementary to the features provided by the Seq [fn:seq] and
CL [fn:cl-lib] libraries (including =cl-loop=) and Emacs's regular looping and
mapping features.

-----
#+begin_center
*NOTE*: Loopy is still in its early stages.\\
Constructive criticism is welcome.  If you see a place for improvement,
please let me know.
#+end_center
-----

# This auto-generated by toc-org.
* Table of Contents                                                :TOC:noexport:
- [[#introduction][Introduction]]
- [[#how-to-use][How to use]]
  - [[#macro-arguments][Macro Arguments]]
  - [[#loop-commands][Loop Commands]]
    - [[#commands-for-generic-evaluation][Commands for Generic Evaluation]]
    - [[#iteration-and-looping-commands][Iteration and Looping Commands]]
    - [[#accumulation-commands][Accumulation Commands]]
    - [[#control-flow][Control Flow]]
      - [[#conditionals][Conditionals]]
      - [[#skipping-an-iteration][Skipping an Iteration]]
      - [[#exiting-the-loop-early][Exiting the Loop Early]]
- [[#adding-custom-commands][Adding Custom Commands]]
- [[#comparing-to-cl-loop][Comparing to =cl-loop=]]
-  [[#real-world-examples][Real-World Examples]]
- [[#footnotes][Footnotes]]

* Introduction

  The =loopy= macro has several possible arguments, each beginning with a
  keyword.

  - =with= declares variables that are bound in order before and around the
    loop, like in a =let*= binding.
  - =before-do= is a list of normal Lisp expressions to run before the loop
    executes.
  - =loop= is a list of special commands that create the loop body.  These
    commands are described in detail in the section [[#loop-commands][Loop Commands]].
  - =after-do= is a list of normal Lisp expressions to run after the successful
    completion of the loop.
  - =finally-do= is a list of normal Lisp expressions that always run,
    regardless of whether an early return was triggered in the loop body.
  - =finally-return= is an expression whose value is always returned, regardless
    of whether an early return was triggered in the loop body.

  The loop commands generally follow the form =(COMMAND VARIABLE-NAME &rest ARGS)=.
  For example,

  - To iterate through a sequence [fn:sequence], use =(seq elem [1 2 3])= (for
    efficiency, there are also more specific commands, like =list=).
  - To collect values into a list, use =(collect my-collection collected-value)=.
  - To just bind a variable to the result of a Lisp expression, use
    =(expr my-var (my-func))=

  Below is a full example of the arguments of the =loopy= macro.  The top-level
  forms have a flexible-order, but meaning is clearest if they have the
  following order.  All of the arguments are technically optional, but having a
  loop without a body wouldn't be useful.

  #+BEGIN_SRC emacs-lisp
    ;; Returns: '((2 4 6 8 10) (1 3 5 7 9)) and prints messages.
    (loopy
     ;; Name the loop `my-loop'.
     my-loop
     ;; Create the locally scoped variable `success-p', initialized to `nil'.
     (with (success-p nil))
     ;; Before starting the loop, print a message.
     (before-do (message "Beginning loop ..."))
     ;; Create the loop body.
     (loop (list i (number-sequence 1 10))        ; Assign `i' from 1 through 10.
           (do (message "Checking number: %d" i)) ; Report the value of `i'.
           (if (cl-evenp i)                       ; If `i' is even, add to the list
               (collect found-evens i)            ; of even numbers, otherwise add
             (collect found-odds i)))             ; to the list of odd numbers.
     ;; If the loop completes successfully, print a message and update `success-p'.
     (after-do (message "Loop completed successfully.")
               (setq success-p t))
     ;; Always report based on the value of `success-p', and message the value of
     ;; the lists of even and odd numbers.
     (finally-do (if success-p
                     (message "Confirmed success reported.")
                   (message "W: Success not confirmed!"))
                 (message "Found evens: %s" found-evens)
                 (message "Found odds: %s" found-odds))
     ;; Always return a list containing the list of even numbers and the list of odd
     ;; numbers.
     (finally-return (list found-evens found-odds)))
  #+END_SRC

  Loopy is not the only Lisp library that uses expressions instead of keyword
  clauses (like in =cl-loop=).  [[https://common-lisp.net/project/iterate/][=iterate=]] and [[https://github.com/Shinmera/for/][=for=]] are two examples in Common
  Lisp.  I know of no examples for Emacs Lisp.

  Though I am not familiar with either, it seems to me that the =loopy= macro is
  more like =for= than it is like =iterate=.  I suspect that, given it’s youth,
  Loopy is much simpler than both.

  #+begin_src emacs-lisp
    ;; Collecting 10 random numbers:
    ;; cl-loop, iterate, for, loopy

    (cl-loop repeat 10 collect (random 10))

    (iterate (repeat 10) (collect (random 10)))

    (for:for ((i repeat 10) (randoms collecting (random 10))))

    (loopy ((repeat 10) (collect (random 10))))
  #+end_src

  Generally, I’d expect that all of the packages handle basic use cases in
  similar ways.  While =iterate= can apparently embed its looping constructs in
  arbitrary code, =loopy= doesn’t allow that, and I believe that the same is
  true of =for=.

  However, Loopy is not yet feature complete.  Please request features or report
  problems in this project’s [[https://github.com/okamsn/loopy/issues][issues tracker]].  While most things are covered,
  full feature parity with =cl-loop= is still being worked on.

* How to Install                                                   :noexport:
  Currently, Loopy must be installed manually.  Here is how one could use
  ~straight.el~ with ~use-package~

  #+begin_src emacs-lisp
    (use-package loopy
      :straight (loopy :type git :host github :repo "okamsn/loopy"))
  #+end_src

* How to use
  :PROPERTIES:
  :CUSTOM_ID: how-to-use
  :END:

  Macro arguments set up the lexical environment the loop runs in, Lisp code
  that runs before or after the loop, and the ultimate return value of the
  macro.  See the section [[#macro-arguments][Macro Arguments]].

  “Loop commands” are the main feature of the =loopy= macro and make up the
  =loop= macro argument, such as =list= in =(list i '(1 2 3))=.  A command
  inserts code into the loop body, but can also perform additional setup, such
  as initializing specified or implicit variables.  Many commands set up a
  condition for ending the loop.  See the section [[#loop-commands][Loop Commands]].

  The loop ends when any condition required by a loop command evaluates to
  false.  If no conditions are needed, the loop runs infinitely until a =return=
  or =return-from= command is reached.  See the section [[#exiting-the-loop-early][Exiting the Loop Early]].

  Except when using [[#accumulation-commands][accumulating loop commands]], return values must be stated
  explicitly, either as an early return in the loop body via the =return= or
  =return-from= commands, or as part of the =finally-return= macro argument.
  =nil= is returned by default.

** Macro Arguments
   :PROPERTIES:
   :CUSTOM_ID: macro-arguments
   :END:

   =loopy= takes at most 7 arguments, which are all technically optional.
   Calling the =loopy= macro without arguments creates an infinite loop that
   does nothing.

   You can name a loop by passing =loopy= an unquoted symbol.  All other
   arguments are expressions that begin with a keyword from the table below.
   For clarity and convenience, some keywords have multiple names and the =loop=
   keyword can be excluded.

   | Keyword                                | Usage                                                   |
   |----------------------------------------+---------------------------------------------------------|
   | =with=, =let*=                         | Declare variables before the loop.                      |
   | =before-do=, =before=                  | Run Lisp expressions before loop starts.                |
   | =loop=, or excluded                    | Add expressions to the loop body and perform setup.     |
   | =after-do=, =after=, =else-do=, =else= | Run Lisp expressions after loop successfully completes. |
   | =finally-do=, =finally=                | Always run Lisp expressions after loop exits.           |
   | =finally-return=, =return=             | Return a value, regardless of how the loop completes.   |

   The loop body and any expressions that are part of the =before-do= and
   =after-do= arguments are contained in a single =cl-block=.  Naming the loop
   really just names the block, allowing for more specific exiting via
   ~cl-return~ and the loop commands that wrap it.

   Finally, =(finally-return 1 2 3)= is the same as =(finally-return (list 1 2
   3))=.  This is convenient when using ~seq-let~, ~pcase-let~,
   ~cl-destructuring-bind~, and the like.

** Loop Commands
   :PROPERTIES:
   :CUSTOM_ID: loop-commands
   :END:

   Loop commands are only valid when inside the =loop= macro argument.  For
   convenience, you do not need to include the keyword =loop= in the argument.
   An expression that doesn’t match any other possible argument is assumed to be
   the =loop= argument.

   Therefore, these are valid:

   #+BEGIN_SRC emacs-lisp
     (loopy (loop (list i '(1 2 3))
                  (collect coll i))
            (finally-return coll))

     (loopy ((list i '(1 2 3))
             (collect coll i))
            (return coll))
   #+END_SRC

   and this is not:

   #+BEGIN_SRC emacs-lisp
     (loopy (with (list i '(1 2 3)))
            (return (collect coll i)))
   #+END_SRC

   Trying to use loop commands where they don't belong will result in errors
   when the code is evaluated.

   Underneath, interpreting a command results in "instructions" that describe
   how to substitute code into the loop body and other locations.  This process
   is described in detail in [[#background-information][Background Information]].

   Some examples of instructions are:
   - Declaring a given variable in a let form to make sure it's locally
     scoped.
   - Declaring a generated variable in a let form to contain a given value.
   - Adding a condition for continuing/exiting the loop.
   - Adding code to be run during the main loop body.
   - Adding code to be run after the main loop body.

  Unless you are writing custom commands, you should not need to know about a
  command’s underlying instructions.  However, you should keep in mind that
  commands and their resulting instructions are evaluated in order.  This means
  that attempting to do something like

   #+BEGIN_SRC emacs-lisp
     (loopy (loop (collect coll i)
                  (list i '(1 2 3)))
            (return coll)) ; => (nil 1 2)
   #+END_SRC

   might not do what you expect, as =i= is assigned a value from the list after
   collecting =i= into =coll=.

   For convenience and understanding, the same command can have multiple names
   (such as =expr= having the alias =exprs=), and some commands can take
   optional arguments (such as =list=).

   For simplicity, the commands are described using the following notation:

   - If a command has multiple names, the names are separated by a vertical
     bar, such as in =expr|exprs=.
   - =VAR= is an unquoted symbol that will be used as a variable name, such as
     =i= in =(list i my-list)=.
   - =FUNC= is a Lisp function name, such as =my-func=, =#'my-func= or
     ='my-func=.
   - =NAME= is an unquoted name of a loop (or, more accurately, of a
     =cl-block=).
   - =EXPR= is a single Lisp expression, such as =(+ 1 2)=, ='(1 2 3)=,
     =my-var=, or =(some-function my-var)=.  =EXPRS= means multiple expressions.
     Really, we are concerned with the value of the expression, not the
     expression itself.
   - =CMD= is a loop command, as opposed to a normal Lisp expression.
     =(list i '(1 2 3))=, =(repeat 5)=, and =(return-from outer-loop 7)=
     are examples of loop commands.  =CMDS= means multiple commands.
   - Optional arguments are surround by brackets.  =[EXPR]= is an optional
     expression, and =[CMD]= is an optional command.  By extension,
     =[EXPRS]= is equivalent to =[EXPR [EXPR [...]]]=, and =[CMDS]= to
     =[CMD [CMD [...]]]=.

   Generally, =VAR= is initialized to ~nil~, but not always.  This document
   tries to note when that is not the case.

   For convenience, =VAR= can be a sequence (either a list or a vector (as a
   stand-in for an array)) of symbols instead of a single symbol.  This tells
   the command to “de-structure” the value of =EXPR=, similar to the functions
   ~seq-let~, ~cl-destructuring-bind~, and ~pcase-let~.  This sequence of
   symbols can be shorter than the destructured sequence, /but not longer/.  If
   shorter, the unassigned elements of the list are simply ignored.  To assign
   the final ~cdr~ of a destructured list, use dotted notation.

   #+begin_src emacs-lisp
     ;; => [(9 10 11 4) (9 10 11 8)]
     (loopy (with (my-array [(1 2 3 4) (5 6 7 8)]))
            ((array-ref (i j k) my-array)
             ;; NOTE: The remaining elements are ignored.
             (do (setf i 9)
                 (setf j 10)
                 (setf k 11)))
            (return my-array))

     ;; => ([9 10 11 4] [9 10 11 8])
     (loopy (with (my-list '([1 2 3 4 ] [5 6 7 8])))
            ((list-ref [i j k] my-list)
             ;; NOTE: The remaining elements are ignored.
             (do (setf i 9)
                 (setf j 10)
                 (setf k 11)))
            (return my-list))

     ;; => (1 (2 3))
     (loopy ((list (i . j) '((1 2 3))))
            (return i j))

     ;; => ((1 22))
     (loopy (with (my-list '((1 2 3))))
            ((list-ref (_ . j) my-list)
             (do (setf j '(22))))
            (return my-list))

     ;; => [(1 22)]
     (loopy (with (my-array [(1 2 3)]))
            ((array-ref (_ . j) my-array)
             (do (setf j '(22))))
            (return my-array))
   #+end_src

   Most commands that assign variables (even the =-ref= commands, which use
   ~setf~-able places instead of actual variables) can use destructuring, but
   not all kinds of destructuring make sense in all situations.

*** Commands for Generic Evaluation
    :PROPERTIES:
    :CUSTOM_ID: commands-for-generic-evaluation
    :END:

    - =(do EXPRS)= :: Evaluate multiple Lisp expressions, like a =progn=.

      You cannot include arbitrary code in the loop body.  Trying to do so will
      result in errors, as the macro will attempt to interpret such code as a
      command.

      #+BEGIN_SRC emacs-lisp
        (loopy ((list i '(1 2 3))
                (do (message "%d" i))))
      #+END_SRC

    - =(expr|exprs|set VAR [EXPRS])= :: Bind =VAR= to each =EXPR= in order.
      Once the last =EXPR= is reached, it is used repeatedly for the rest of the
      loop.  With no =EXPR=, =VAR= is repeatedly bound to =nil=.

      *NOTE*: Loops are locally scoped, so using this command does not always
      have the same effect as using =(do (setq VAR EXPR))=.

      #+BEGIN_SRC emacs-lisp
        (loopy ((repeat 5)
                (expr i 1 2 3)
                (collect coll i))
               (return coll)) ; => '(1 2 3 3 3)

        (loopy ((repeat 5)
                (expr i 0 (1+ i))
                (collect coll i))
               (return coll)) ; => '(0 1 2 3 4)
      #+END_SRC

    - =(group [CMDS])= :: Evaluate multiple loop commands, as if in a =progn=.
      This is similar to =do=, but runs commands instead of normal Lisp
      expressions.  Currently, this command is only useful when used with the
      =if= command.

*** Iteration and Looping Commands
    :PROPERTIES:
    :CUSTOM_ID: iteration-and-looping-commands
    :END:

    Iteration commands bind local variables and determine when the loop ends.
    If no command sets that condition, then the loop runs forever.

    The =-ref= (as in “reference”) commands create ~setf~-able places instead of
    true variables.  Like other commands, they can also use destructuring.  In
    such cases, the variables in the sequence =VAR= are also ~setf~-able places
    instead of true variables.

    - =(array VAR EXPR)= :: Loop through the elements of the array =EXPR=.

      #+BEGIN_SRC emacs-lisp
        (loopy ((array i [1 2 3])
                (do (message "%d" i))))
      #+END_SRC

    - =(array-ref|arrayf VAR EXPR)= :: Loop through the elements of the array
      =EXPR=, binding =VAR= as a ~setf~-able place.

      #+BEGIN_SRC emacs-lisp
        (loopy (with (my-str "cat"))
               (loop (array-ref i my-str)
                     (do (setf i ?a)))
               (return my-str)) ; => "aaa"
      #+END_SRC

    - =(cons|conses VAR EXPR [FUNC])= :: Loop through the cons cells of =EXPR=.
      Optionally, find the cons cells via =FUNC= instead of =cdr=.

      To avoid unneeded variables, when not destructuring, =VAR= is initialized
      to =EXPR= instead of ~nil~.

      #+BEGIN_SRC emacs-lisp
        (loopy (loop (cons i '(1 2 3))
                     (collect coll i))
               (finally-return coll)) ; => ((1 2 3) (2 3) (3))
      #+END_SRC

    - =(list VAR EXPR [FUNC])= :: Loop through the elements of the list =EXPR=.
      Optionally, update the list by =FUNC= instead of =cdr=.

      #+BEGIN_SRC emacs-lisp
        (loopy ((list i (number-sequence 1 10 3)) ; Inclusive, so '(1 4 7 10).
                (do (message "%d" i))))
      #+END_SRC

    - =(list-ref|listf VAR EXPR [FUNC])= :: Loop through the elements of the
      list =EXPR=, binding =VAR= as a ~setf~-able place.  Optionally, update the
      list by =FUNC= instead of =cdr=.

      #+BEGIN_SRC emacs-lisp
        (loopy (with (my-list '(1 2 3)))
               (loop (list-ref i my-list)
                     (do (setf i 7)))
               (finally-return my-list)) ; Returns '(7 7 7).
      #+END_SRC

    - =(repeat EXPR)= :: Add a condition that the loop should stop after
      =EXPR= iterations.

      #+BEGIN_SRC emacs-lisp
        (loopy ((repeat 3)
                (do (message "Messaged three times."))))
      #+END_SRC

    - =(repeat VAR EXPR)= :: Add a condition that the loop should stop after
      =EXPR= iterations.  =VAR= starts at 0, and is incremented by 1 at the
      end of the loop.

      #+BEGIN_SRC emacs-lisp
        (loopy ((repeat i 3)
                (do (message "%d" i))))
      #+END_SRC

    - =(seq VAR EXPR)= :: Loop through the sequence =val=, binding =var= to
      the elements of the sequence.

      #+BEGIN_SRC emacs-lisp
        (loopy ((seq i [1 2 3]) (collect coll i))
               (return coll)) ; => (1 2 3)
      #+END_SRC

    - =(seq-ref|seqf VAR EXPR)= :: Loop through the elements of the sequence
      =val=, binding =var= as a ~setf~-able place.

      #+BEGIN_SRC emacs-lisp
        (loopy (with (my-seq '(1 2 3 4)))
               (loop (seq-ref i my-seq)
                     (do (setf i 7)))
               (return my-seq)) ; => '(7 7 7 7)
      #+END_SRC

*** Accumulation Commands
    :PROPERTIES:
    :CUSTOM_ID: accumulation-commands
    :END:

    Accumulation commands are used to repeatedly update a variable using a
    value.  In that way, they are something like shortcuts for several different
    ways of using the =expr= command.  For example, =(sum my-sum my-var)= is
    really just another way of saying =(expr my-sum 0 (+ my-sum my-var))=.

    If needed, you can refer to the same variable in multiple accumulation
    commands, such as in the following.

    #+begin_src emacs-lisp
      (loopy ((list i '(1 2 3))
              (collect coll i)
              (collect coll (+ i 5)))
             (return coll)) ; => (1 6 2 7 3 8)
    #+end_src

    Using a “destructuring” =VAR= argument in accumulation commands works a bit
    differently than how it would in iteration commands.  While iteration
    commands just assign variables the values that make up the destructured
    =EXPR=, accumulation commands accumulate each of those values into their
    respective variable in the sequence =VAR=.

    #+begin_src emacs-lisp
      ;; => ((1 4) (2 5) (3 6))
      (loopy ((list elem '((1 2 3) (4 5 6)))
              (collect (coll1 coll2 coll3) elem))
             (return coll1 coll2 coll3))

      ;; => (5 7 9)
      (loopy ((list elem '((1 2 3) (4 5 6)))
              (sum (sum1 sum2 sum3) elem))
             (return sum1 sum2 sum3))

      ;; Returns the same values as above.
      (loopy ((list elem '((1 2 3) (4 5 6)))
              (expr sum1 (cl-first elem)  (+ sum1 (cl-first elem)))
              (expr sum2 (cl-second elem) (+ sum2 (cl-second elem)))
              (expr sum3 (cl-third elem)  (+ sum3 (cl-third elem))))
             (return sum1 sum2 sum3))
    #+end_src

    Using an accumulation command implies a return value.  If there are multiple
    accumulations, or destructured accumulations, than the implied return value
    of the loop is a list of those accumulated values in the order that their
    respective command occurs in the loop body.  This implied return value can
    be overridden by using the =return= and =return-from= loop commands or a
    =finally-return= macro argument.

    #+begin_src emacs-lisp
      ;; Note that `my-collection' is the first value in the implied return,
      ;; even though the collection happens after the first summation step.
      ;;
      ;; => (((4 5 6)) 5 7 9), for `my-collection', `sum1', `sum2', `sum3'
      (loopy ((list elem '((1 2 3) (4 5 6)))
              (when (equal elem '(4 5 6))
                (collect my-collection elem))
              (sum (my-sum1 my-sum2 my-sum3) elem)))
    #+end_src

    Like ~cl-loop~, you do not need to supply a variable name to accumulation
    commands.  With only one argument, they accumulate values into a generated
    variable and use that variable as an implicit return value.  Unlike
    ~cl-loop~, this generation means that if you want accumulation commands to
    act on the same variable, you must supply the same =VAR= as the first
    argument to each command.

    - =(append VAR EXPR)= :: Repeatedly =append= the value of =EXPR= to =VAR=.
      =VAR= starts as =nil=.

      #+BEGIN_SRC emacs-lisp
        (loopy ((list i '((1 2 3) (4 5 6)))
                (append coll i))
               (return coll)) ; => '(1 2 3 4 5 6)
      #+END_SRC

    - =(collect VAR EXPR)= :: Collect the value of =EXPR= into a list.  To
      better performance, =collect= behaves differently depending on whether
      =VAR= is provided.

      When provided, repeatedly =append= a list containing the value of =EXPR=
      to =VAR=.  When not provided, repeatedly =push= the value of =EXPR= into a
      list, and =nreverse= the list at the end of the loop.

      =VAR= starts as =nil=.

      #+BEGIN_SRC emacs-lisp
        ;; => '(1 2 3)
        (loopy ((list i '(1 2 3))
                (collect i)))

        ;; => '((1 2 3) ((1) (1 2) (1 2 3)))
        (loopy ((list i '(1 2 3))
                (collect coll1 i)
                (collect coll1)))
      #+END_SRC

      If you want to =push= values into a provided variable (instead of
      repeatedly appending a list of one element), use the =push-into= command
      (see below).

    - =(concat VAR EXPR)= :: Repeatedly =concat= the value of =EXPR= onto the
      end of =VAR=.  =VAR= starts as =nil=.  See the =vconcat= command for
      vectors.

      #+BEGIN_SRC emacs-lisp
        (loopy ((list i '("a" "b" "c"))
                (concat str i))
               (return str)) ; => "abc"
      #+END_SRC

    - =(count VAR EXPR)= :: Count the number of times that =EXPR= evaluates to a
      non-nil value, adding 1 to =VAR= each time.  =VAR= starts at 0.

      #+BEGIN_SRC emacs-lisp
        (loopy ((list i '(1 nil 3 nil 5))
                (count non-nil-count i))
               (return non-nil-count)) ; => 3
      #+END_SRC

    - =(max|maximize VAR EXPR)= :: Repeatedly set =VAR= to the greater of =VAR=
      and the value of =EXPR=.  =VAR= starts at =-1.0e+INF=, so that any other
      value should be greater that it.

      #+BEGIN_SRC emacs-lisp
        (loopy ((list i '(1 11 2 10 3 9 4 8 5 7 6))
                (max my-max i))
               (return my-max)) ; => 11
      #+END_SRC

    - =(min|minimize VAR EXPR)= :: Repeatedly set =VAR= to the lesser of =VAR=
      and the value of =EXPR=.  =VAR= starts at =1.0e+INF=, so that any other
      value should be less than it.

      #+BEGIN_SRC emacs-lisp
        (loopy ((list i '(1 11 2 10 3 0 9 4 8 5 7 6))
                (min my-min i))
               (return my-min)) ; => 0
      #+END_SRC

    - =(nconc VAR EXPR)= :: Repeatedly concatenate the value of =EXPR= onto
      =VAR= with =nconc=.  Unlike =append=, =nconc= does not concatenate copies
      of the lists, but modifies =VAR= directly.

      #+BEGIN_SRC emacs-lisp
        (loopy (loop (list i '((1 2 3 4) (5 6 7 8)))
                     (nconc my-new-list i))
               (return my-new-list)) ; => '(1 2 3 4 5 6 7 8)
      #+END_SRC

    - =(push|push-into VAR EXPR)= :: Repeatedly =push= =EXPR= into =VAR=.  =VAR=
      stars as =nil=.

      #+BEGIN_SRC emacs-lisp
        (loopy ((seq i [1 2 3])
                (push reversed i))
               (finally-return (nreverse reversed))) ; => '(1 2 3)
      #+END_SRC

    - =(sum VAR EXPR)= :: Repeatedly set =VAR= to the sum of the value of =EXPR=
      and =VAR=.  =VAR= starts at 0.

      #+BEGIN_SRC emacs-lisp
        (loopy ((list i '(1 2 3 4))
                (sum my-sum i))
               (return my-sum)) ; => 10
      #+END_SRC

    - =(vconcat VAR EXPR)= :: Repeatedly =vconcat= the value of =EXPR= onto
      =VAR=.  =VAR= starts as =nil=.

      #+BEGIN_SRC emacs-lisp
        (loopy ((list i '([1 2 3] [4 5 6]))
                (vconcat vector i))
               (return vector)) ; => [1 2 3 4 5 6]
      #+END_SRC

*** Control Flow
    :PROPERTIES:
    :CUSTOM_ID: control-flow
    :END:

**** Conditionals
     :PROPERTIES:
     :CUSTOM_ID: conditionals
     :END:

     Conditional commands in =loopy= can take multiple sub-commands, and work
     like their Lisp counterparts.  There is therefore no need for an =and=
     command as used in =cl-loop=.

     - =(when EXPR CMDS)= :: Run =CMDS= only if =EXPR= is non-nil.

       #+BEGIN_SRC emacs-lisp
         ;; Get only the inner lists with all even numbers.
         ;; => '((2 4 6) (8 10 12) (16 18 20))
         (loopy ((list i '((2 4 6) (8 10 12) (13 14 15) (16 18 20)))
                 (when (loopy ((list j i)
                               (when (cl-oddp j)
                                 (return nil)))
                              (else-do (cl-return t)))
                   (collect only-evens i)))
                (finally-return only-evens))
       #+END_SRC

     - =(if EXPR CMDS)= :: Run the first command if =EXPR= is non-nil.
       Otherwise, run the remaining commands.

       #+BEGIN_SRC emacs-lisp
         ;; => '((7 5 3 1) (6 4 2) (3 3 3))
         (loopy ((seq i [1 2 3 4 5 6 7])
                 (if (cl-oddp i)
                     (push-into reversed-odds i)
                   (push-into reversed-evens i)
                   (push-into some-threes 3)))
                (finally-return (list reversed-odds
                                      reversed-evens
                                      some-threes)))
       #+END_SRC

     - =(cond [(EXPR CMDS) [...]])= :: For the first =EXPR= to evaluate to
       non-nil, run the following commands =CMDS=.

       #+BEGIN_SRC emacs-lisp
         ;; => '((2 4 6) (1 3 5) ("cat" "dog"))
         (loopy ((list i '(1 2 3 "cat" 4 5 6 "dog"))
                 (cond
                  ((not (numberp i)) (collect not-numbers i))
                  ((cl-evenp i)      (collect evens i))
                  (t                 (collect odds i))))
                (return evens odds not-numbers))
       #+END_SRC

**** Skipping an Iteration
     :PROPERTIES:
     :CUSTOM_ID: skipping-an-iteration
     :END:

     - =(skip|continue)= :: Go to next loop iteration.

       #+BEGIN_SRC emacs-lisp
         ;; => (2 4 6 8 12 14 16 18)
         (loopy ((seq i (number-sequence 1 20))
                 (when (zerop (mod i 10))
                   (skip))
                 (when (cl-evenp i)
                   (push-into my-collection i)))
                (finally-return (nreverse my-collection)))
       #+END_SRC

**** Exiting the Loop Early
     :PROPERTIES:
     :CUSTOM_ID: exiting-the-loop-early
     :END:

     The loop is contained in a =cl-block=, and these forms are all variations
     of =cl-return-from= underneath.  Indeed, you could use =(do (cl-return-from
     NAME [EXPR]))= to achieve the same effect.

     If multiple =EXPR= are passes to the =return= or =return-from=, these
     commands will return a list of those =EXPR=.  If not =EXPR= is given, =nil=
     is returned.

     - =(return [EXPRS])= :: Leave the current loop, returning =[EXPRS]=.

       #+BEGIN_SRC emacs-lisp
         (loopy (with  (j 0))
                ((do (cl-incf j))
                 (when (> j 5)
                   (return j)))) ; => 6
       #+END_SRC

     - =(return-from NAME [EXPRS])= :: Leave the loop =NAME=, returning =[EXPRS]=.

       #+BEGIN_SRC emacs-lisp
         ;; => 'bad-val?
         (loopy outer-loop
                ((list inner-list '((1 2 3) (1 bad-val? 1) (4 5 6)))
                 (do (loopy ((list i inner-list)
                             (when (eq i 'bad-val?)
                               (return-from outer-loop 'bad-val?)))))))
       #+END_SRC

* Adding Custom Commands
  :PROPERTIES:
  :CUSTOM_ID: adding-custom-commands
  :END:

   The core working of =loopy= is taking a command and generating code that is
   substituted into or around a loop body.

   For example, parsing the command =(list i '(1 2 3))= produces the following
   list of instructions.  Some commands require the creation of unique temporary
   variables, such as =g3019= in the below output. Such variables are called
   “implicit", as opposed to the explicitly named variable =i= in the command.

   #+BEGIN_SRC emacs-lisp
     ((loopy--implicit-vars g3019 '(1 2 3))
      (loopy--explicit-vars i nil)
      (loopy--pre-conditions consp g3019)
      (loopy--main-body setq i (car g3019))
      (loopy--latter-body setq g3019 (cdr g3019)))
   #+END_SRC

   The ~car~ of an instruction is the place to put code and the ~cdr~ of the
   instruction is said code to put.  You can see that not all of the code to be
   inserted is a valid Lisp form.  Instead of being evaluated as an expression,
   some instructions insert pairs of names and values into variable lists like
   in ~let~ and ~let*~ .

   | Place                     | Code                         |
   |---------------------------+------------------------------|
   | =loopy--implicit-vars=    | =(g3019 '(1 2 3))=           |
   | =loopy--explicit-vars=    | =(i nil)=                    |
   | =loopy--pre-conditions=   | =(consp g3019)=              |
   | =loopy--main-body=        | =(setq i (car g3019))=       |
   | =loopy--latter-body=      | =(setq g3019 (cdr g3019))=   |

   Commands are parsed by =loopy--parse-body-forms=, which receives a list of
   commands and returns a list of instructions.  For commands that take
   sub-commands as arguments (such as =cond=, =if=, and =when=), more specific
   parsing functions are called in a mutually recursive fashion (e.g.,
   Function-1 uses Function-2 which uses Function-1, and so on).

   For example, consider the function =loopy--parse-conditional-forms=, which
   parses the =if=, =when=, and =unless= commands.  It needs to be able to group
   any code going to the loop body under its respective conditional control
   structure.  To do this, it uses =loopy--parse-body-forms= to turn its
   sub-commands into a list of instructions, and then checks the =car= of each
   instruction.

   #+BEGIN_SRC emacs-lisp
     (defun loopy--parse-conditional-forms (wrapper condition forms &optional loop-name)
       "Parse FORMS, wrapping `loopy--main-body' expressions in a conditional form.
     The instructions (e.g., return expressions) are wrapped with a
     WRAPPER with CONDITION.  Optionally needs LOOP-NAME for block
     returns."
       (let ((full-instructions)
             (sub-instructions (loopy--parse-body-forms forms loop-name))
             (conditional-body))
         (dolist (instruction sub-instructions)
           (cl-case (car instruction)
             (loopy--main-body (push (cdr instruction) conditional-body))
             (t                (push instruction full-instructions))))
         (push `(loopy--main-body . (,wrapper ,condition ,@conditional-body))
               full-instructions)
         full-instructions))
   #+END_SRC

   The hardest part of this exchange is making sure the inserted code ends up in
   the correct order.

   A loop body command has 7 main places to put code:

   - =loopy--explicit-generalized-vars= :: Lists of a symbol and a macro
     expansion that will be given to =cl-symbol-macrolet=.  This is used to
     create named ~setf~-able places.  The expansion you use depends on the kind
     of sequence and how the it is updated.

     For example, =(list-ref i my-list)= declares =i= to be a symbol which
     expands to =(car TEMP-VAR)=, in which =TEMP-VAR= holds the value of
     =my-list=.  At the end of the loop body, =TEMP-VAR= is set to its =cdr=,
     ensuring that the next call to =car= returns the correct value.

   - =loopy--implicit-vars= :: Lists of a symbol and an expression that will be
     given to =let=.  This is used for creating variables that are not named but
     must exist, such as for holding ='(1 2 3)= in =(list i '(1 2 3))=.

   - =loopy--explicit-vars= :: Lists of a symbol and an expression that will be
     given to =let=.  This is needed to ensure that variables explicitly named
     in commands are locally scoped, such as the =i= in =(list i '(1 2 3))=.

   - =loopy--pre-conditions= :: Expressions that determine if the =while=
     loop runs/continues, such as whether a list still has elements in it.
     If there is more than one expression, than all expressions are used in
     an =and= special form.

   - =loopy--main-body= :: Expressions that make up the main body of the
     loop.

   - =loopy--latter-body= :: Expressions that need to be run after the main
     body, such as updating implicit variables.

   - =loopy--post-conditions= :: Expressions that determine whether the
     =while= loop continues, but checked after the loop body has run.  The
     code from this is ultimately appended to the latter body before being
     substituted in.

   There are 5 more variables a loop command can push to, but they are derived
   from the macro's arguments.  Adding to them after using a macro argument
   might lead to unintended behavior.  You might wish to use them if, for
   example, you are concerned with what happens after the loop exits/completes.

   - =loopy--with-vars= :: Lists of a symbol and an expression that will be
     given to =let*=.  These are derived from the =with= macro argument.

   - =loopy--before-do= :: Expressions to evaluate before the loop.  These are
     derived from the =before-do= macro argument.

   - =loopy--after-do= :: Expressions to evaluate after the loop completes
     successfully.  These are derived from the =after-do= macro argument.

   - =loopy--final-do= :: Expressions to evaluate after the loop completes,
     regardless of success.  These are derived from the =finally-do= macro
     argument.

   - =loopy--final-return= :: An expression that is always returned by the
     macro, regardless of any early returns in the loop body.  This is
     derived from the =finally-return= macro argument.

   The structure of the macro’s expanded code depends on the features used
   (e.g., =loopy= won’t try to declare variables if none exist), but the result
   will work similar to the below example.

   #+BEGIN_SRC emacs-lisp
     `(cl-symbol-macrolet ,loopy--explicit-generalized-vars
        (let* ,loopy--with-vars
          (let ,(append loopy--implicit-vars loopy--explicit-vars)
            (let ((loopy--early-return-capture
                   (cl-block ,loopy--name-arg
                     ,@loopy--before-do
                     (while ,(cl-case (length loopy--pre-conditions)
                               (0 t)
                               (1 (car loopy--pre-conditions))
                               (t (cons 'and loopy--pre-conditions)))
                       (cl-tagbody
                        ,@loopy--main-body
                        loopy--continue-tag
                        ,@loopy--latter-body))
                     ,@loopy--after-do
                     nil)))
              ,@loopy--final-do
              ,(if loopy--final-return
                   loopy--final-return
                 'loopy--early-return-capture)))))
   #+END_SRC

   For more on custom commands, see the wiki page [[https://github.com/okamsn/loopy/wiki/Custom-Commands][Custom Commands]].

* Comparing to =cl-loop=
  :PROPERTIES:
  :CUSTOM_ID: how-does-it-compare-to-other-approaches
  :END:

  See the wiki page [[https://github.com/okamsn/loopy/wiki/Versus-%60cl-loop%60][Versus =cl-loop=]].


*  Real-World Examples

  See the wiki page [[https://github.com/okamsn/loopy/wiki/Examples][Examples]].

* Footnotes

[fn:cl-loop]
[[https://www.gnu.org/software/emacs/manual/html_node/cl/Loop-Facility.html#Loop-Facility]]

[fn:seq]
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Sequence-Functions.html]],
[[info:elisp#Sequence Functions]]

[fn:cl-lib]
[[https://www.gnu.org/software/emacs/manual/html_node/cl/index.html]], [[info:cl]]

[fn:sequence]
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Sequences-Arrays-Vectors.html]],
[[info:elisp#Sequences Arrays Vectors]]
