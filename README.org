#+title: Loopy: A Looping and Iteration Macro
#+author: Earl Hyatt
#+export_file_name: loopy

# Make sure to export all headings as such.  Otherwise, some links to
# sub-headings won’t work.
#+options: H:6
# Some parsers require this option to export footnotes.
#+options: f:t

=loopy= is a macro meant for iterating and looping.  It is similar in usage to
[[https://www.gnu.org/software/emacs/manual/html_node/cl/Loop-Facility.html#Loop-Facility][~cl-loop~]] but uses symbolic expressions rather than keywords.

=loopy= should be complementary to the features provided by the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Sequences-Arrays-Vectors.html][Seq]] and [[https://www.gnu.org/software/emacs/manual/html_node/cl/index.html][CL]]
libraries (including ~cl-loop~) and Emacs's regular looping and mapping
features.

For detailed information, see [[file:doc/loopy-doc.org][the documentation file]].  This README is just an
overview.

-----
#+begin_center
*NOTE*: Loopy is still in its early stages.\\
Constructive criticism is welcome.  If you see a place for improvement,
please let me know.
#+end_center
-----

# This auto-generated by toc-org.
* Table of Contents                                                :TOC:noexport:
- [[#introduction][Introduction]]
- [[#similar-libraries][Similar Libraries]]
- [[#how-to-install][How to Install]]
- [[#multiple-kinds-of-destructuring][Multiple Kinds of Destructuring]]
- [[#adding-custom-commands][Adding Custom Commands]]
- [[#comparing-to-cl-loop][Comparing to =cl-loop=]]
- [[#real-world-examples][Real-World Examples]]

* Introduction

  The ~loopy~ macro expands to a ~while~ loop whose context is determined by the
  macro's arguments and whose body is determined by special "loop commands"
  passed in the =loop= macro argument.

  For example, to iterate through the items in a list, one could use the =list=
  loop command.  To collect values into a list, one can use the =collect=
  command.

  #+begin_src emacs-lisp
    ;; => (2 3 4)
    (loopy (with (my-variable 1))
           (loop (list elem '(1 2 3))
                 (collect (+ elem my-variable))))
  #+end_src

  This is very similar to how it would be done with ~cl-loop~:

  #+begin_src emacs-lisp
    (cl-loop with my-var = 1
             for elem in '(1 2 3)
             collect (+ i my-var))
  #+end_src

  Because ~loopy~ uses symbolic expressions instead of clauses like in
  ~cl-loop~, things like conditionally updating variables are much easier.

  #+begin_src emacs-lisp
    (loopy (loop (list i (number-sequence 1 20))
                 (if (cl-evenp i)
                     (set last-even-found i)
                   (collect odds i)))
           (after-do
            (message "Found odds: %s" odds)
            (message "Last even found: %d" last-even-found))
           (finally-return odds))
  #+end_src

  The =loopy= macro has several possible arguments, each beginning with a
  keyword.

  - =with=, =let*= :: Declares and initializes variables that are bound in order
    before and around the loop, like in a =let*= binding.
  - =without=, =no-init= :: Declares variables that ~loopy~ shouldn't try to
    initialize.  Without this, ~loopy~ might set a variable to ~nil~ or ~0~, for
    example.
  - =before-do=, =before= :: A list of normal Lisp expressions to run before the loop
    executes.
  - =loop= :: A list of loop commands, which create the loop body.  These
    commands are described in detail in the section [[file:doc/loopy.org::#loop-commands][Loop Commands]].
  - =after-do=, =after=, =else-do=, =else= :: A list of normal Lisp expressions
    to run after the successful completion of the loop.
  - =finally-do=, =finally= :: A list of normal Lisp expressions that always
    run, regardless of whether an early return was triggered in the loop body.
  - =finally-return=, =return= :: An expression whose value is always returned,
    regardless of whether an early return was triggered in the loop body.  If
    given several expressions, returns their values as one list.
  - =flag=, =flags= :: Optional triggers that change how ~loopy~ behaves.  For
    example, one can use =(flag dash)= to use =dash= for destructuring values
    instead of ~loopy~'s normal behavior.

  The code is expanded so that the loop and any expressions from the =before-do=
  and =after-do= macro arguments are contained in a single ~cl-block~.  Naming
  the loop can be done by passing a symbol as a macro argument, and names this
  block.  This allows for any call to ~cl-return~ (for convenience, already
  wrapped in a =return= loop command) to exit the loop or change the macro's
  return value.  The default return value is ~nil~.

  Loop commands determine when and how the loop exits, and generally follow the
  form =(COMMAND VARIABLE-NAME &rest ARGS)=.  For example,

  - To iterate through a sequence [fn:sequence], use =(seq elem [1 2 3])= (for
    efficiency, there are also more specific commands, like =list=).
  - To collect values into a list, use =(collect my-collection collected-value)=.
  - To just bind a variable to the result of a Lisp expression, use
    =(expr my-var (my-func))=.


  These commands can use destructuring, even accumulation commands.
  #+begin_src emacs-lisp
    ;; = >((1 5) (2 6) (3 7) (4 8))
    (loopy (loop (list [first-half second-half] '([(1 2) (3 4)]
                                                  [(5 6) (7 8)]))
                 (collect (first-quarter second-quarter) first-half)
                 (collect (third-quarter fourth-quarter) second-half)))
  #+end_src

  Other commands create ~setf~-able places.

  #+begin_src emacs-lisp
    ;; => 6, from summing [0 2 0 4]
    (loopy (with (my-array [1 2 3 4]))
           ((array-ref elem my-array)
            (when (cl-oddp elem)
              (do (setf elem 0))))
           (finally-return (cl-reduce #'+ my-array)))

    ;; For completeness, more idiomatic equivalent of above:
    ;; => 6
    (loopy (with (my-array [1 2 3 4]))
           (loop (array elem my-array)
                 (when (cl-evenp elem)
                   (sum elem))))
  #+end_src

  Like in ~cl-loop~, accumulation commands can accumulate into implicit
  variables.  As seen in the above example, we did not need to use =(sum my-sum
  elem)=, as =(sum elem)= automatically initializes a variable adds to it the
  value of =elem=.  The variables used by accumulation commands are
  automatically returned by ~loopy~ without needing an explicit ~return~ usage.
  If multiple accumulation variables are used, they will be returned in a list
  in the order that they appear in the loop body.

  #+begin_src emacs-lisp
    ;; => (("cat" "dog") (2 4 6) (1 3 5))
    (loopy ((list i '(1 2 3 "cat" 4 5 6 "dog"))
            (cond
             ((not (numberp i)) (collect not-numbers i))
             ((cl-evenp i)      (collect evens i))
             (t                 (collect odds i)))))

    ;; More explicitly:
    (loopy ((list i '(1 2 3 "cat" 4 5 6 "dog"))
            (cond
             ((not (numberp i)) (collect not-numbers i))
             ((cl-evenp i)      (collect evens i))
             (t                 (collect odds i))))
           ;; Same as (finally-return (list not-numbers evens odds)):
           (return not-numbers evens odds))
  #+end_src

  Below is an admittedly complicated example of most of the arguments of the
  ~loopy~ macro.  The top-level forms have a flexible-order, but meaning is
  clearest if they have the following order.  All of the arguments are
  technically optional, but passing ~loopy~ no arguments creates an infinite
  ~while~-loop that does nothing.

  #+BEGIN_SRC emacs-lisp
    ;; Returns: '((2 4 6 8 10) (1 3 5 7 9)) and prints messages.
    (loopy
     ;; Name the loop `my-loop'.
     my-loop
     ;; Create the locally scoped variable `success-p', initialized to `nil'.
     (with (success-p nil))
     ;; Before starting the loop, print a message.
     (before-do (message "Beginning loop ..."))
     ;; Create the loop body.
     (loop (list i (number-sequence 1 10))        ; Assign `i' from 1 through 10.
           (do (message "Checking number: %d" i)) ; Report the value of `i'.
           (if (cl-evenp i)                       ; If `i' is even, add to the list
               (collect found-evens i)            ; of even numbers, otherwise add
             (collect found-odds i)))             ; to the list of odd numbers.
     ;; If the loop completes successfully, print a message and update `success-p'.
     (after-do (message "Loop completed successfully.")
               (setq success-p t))
     ;; Always report based on the value of `success-p', and message the value of
     ;; the lists of even and odd numbers.
     (finally-do (if success-p
                     (message "Confirmed success reported.")
                   (message "W: Success not confirmed!"))
                 (message "Found evens: %s" found-evens)
                 (message "Found odds: %s" found-odds))
     ;; Always return a list containing the list of even numbers and the list of odd
     ;; numbers.
     (finally-return (list found-evens found-odds)))
  #+END_SRC

* Similar Libraries
  Loopy is not the only Lisp library that uses expressions instead of keyword
  clauses (like in =cl-loop=).  [[https://common-lisp.net/project/iterate/][=iterate=]] and [[https://github.com/Shinmera/for/][=for=]] are two examples in Common
  Lisp.  I know of no examples for Emacs Lisp.

  Though I am not familiar with either, it seems to me that the =loopy= macro is
  more like =for= than it is like =iterate=.  I suspect that, given it’s youth,
  Loopy is much simpler than both.

  #+begin_src emacs-lisp
    ;; Collecting 10 random numbers:
    ;; cl-loop, iterate, for, loopy

    (cl-loop repeat 10 collect (random 10))

    (iterate (repeat 10) (collect (random 10)))

    (for:for ((i repeat 10) (randoms collecting (random 10))))

    (loopy ((repeat 10) (collect (random 10))))
  #+end_src

  Generally, I’d expect that all of the packages handle basic use cases in
  similar ways.  While =iterate= can apparently embed its looping constructs in
  arbitrary code, =loopy= doesn’t allow that, and I believe that the same is
  true of =for=.

  However, Loopy is not yet feature complete.  Please request features or report
  problems in this project’s [[https://github.com/okamsn/loopy/issues][issues tracker]].  While most things are covered,
  full feature parity with =cl-loop= is still being worked on.

* How to Install
  Currently, Loopy must be installed manually.  Here is how one could use
  ~straight.el~ with ~use-package~

  #+begin_src emacs-lisp
    (use-package loopy
      :straight (loopy :type git :host github :repo "okamsn/loopy"
                       :files (:defaults (:exclude "loopy-dash.el"))))

    ;; Optional support for destructuring with Dash.
    (use-package loopy-dash
      :after (loopy)
      :demand t
      :straight (loopy-dash :type git :host github :repo "okamsn/loopy"
                            :files ("loopy-dash.el")))
  #+end_src

* Multiple Kinds of Destructuring

  ~loopy~ can optionally use destructuring provided by ~pcase-let~, ~seq-let~,
  the =dash= library, as well as its own kind.  This provides greater
  flexibility and allows you to use destructuring patterns that you're already
  familiar with.

  These features can be enabled with "flags", described in the section
  [[file:doc/loopy-doc.org::*Changing the Macro's Behavior with Flags][Changing the Macro's Behavior with Flags]] in the documentation.

  Here are a few examples that demonstrate how ~loopy~ can use destructuring
  with accumulation commands.

  #+begin_src emacs-lisp
    (require 'loopy-dash)
    ;; => (((1 (2 3)) (4 (5 6))) ; whole
    ;;     (1 4)                 ; i
    ;;     (3 6))                ; k
    (loopy (flag dash)
           (loop (list elem '((1 (2 3)) (4 (5 6))))
                 (collect (whole &as i (_ k)) elem)))

    ;; = > ((3 5) (4 6))
    (loopy (flag dash)
           ((list (&plist :a a  :b b)
                  '((:a 3  :b 4 :c 7) (:g 8 :a 5 :b 6)))
            (collect a-vals a)
            (collect b-vals b)))

    (require 'loopy-pcase)
    ;; => ((1 4) (3 6))
    (loopy (flag pcase)
           (loop (list elem '((1 (2 3)) (4 (5 6))))
                 (collect `(,a (,_ ,b)) elem)))

    ;; => ((1 6) (3 8) ([4 5] [9 10]))
    (require 'loopy-seq)
    (loopy (flag seq)
           (loop (list elem '([1 2 3 4 5] [6 7 8 9 10]))
                 (collect [a _ b &rest c] elem)))
  #+end_src

  For more on how =dash= does destructuring, see their documentation on the [[https://github.com/magnars/dash.el#-let-varlist-rest-body][-let]]
  form.

* Adding Custom Commands
  :PROPERTIES:
  :CUSTOM_ID: adding-custom-commands
  :END:

  It is easy to create custom commands for Loopy.  To see how, see the section
  [[file:doc/loopy-doc.org::#adding-custom-commands][Adding Custom Commands]] in the documentation or a copy of this information on
  the wiki page [[https://github.com/okamsn/loopy/wiki/Custom-Commands][Custom Commands]].

* Comparing to =cl-loop=
  :PROPERTIES:
  :CUSTOM_ID: how-does-it-compare-to-other-approaches
  :END:

  See the wiki page [[https://github.com/okamsn/loopy/wiki/Versus-%60cl-loop%60][Versus =cl-loop=]].


* Real-World Examples

  See the wiki page [[https://github.com/okamsn/loopy/wiki/Examples][Examples]].

# Local Variables:
# org-link-file-path-type: relative
# End:
