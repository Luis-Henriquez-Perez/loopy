#+title: Loopy: A Looping and Iteration Macro
#+author: Earl Hyatt
#+export_file_name: loopy

# Make sure to export all headings as such.  Otherwise, some links to
# sub-headings won’t work.
#+options: H:6
# Some parsers require this option to export footnotes.
#+options: f:t

=loopy= is a macro meant for iterating and looping.  It is similar in usage to
[[https://www.gnu.org/software/emacs/manual/html_node/cl/Loop-Facility.html#Loop-Facility][~cl-loop~]] but uses symbolic expressions rather than keywords.

=loopy= should be complementary to the features provided by the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Sequences-Arrays-Vectors.html][Seq]] and [[https://www.gnu.org/software/emacs/manual/html_node/cl/index.html][CL]]
libraries (including ~cl-loop~) and Emacs's regular looping and mapping
features.

For detailed information, see [[file:doc/loopy-doc.org][the documentation file]].  This README is just an
overview.

-----
#+begin_center
*NOTE*: Loopy is still in its early stages.\\
Constructive criticism is welcome.  If you see a place for improvement,
please let me know.
#+end_center
-----

# This auto-generated by toc-org.
* Table of Contents                                                :TOC:noexport:
- [[#introduction][Introduction]]
- [[#similar-libraries][Similar Libraries]]
- [[#destructuring-with-dash][Destructuring with Dash]]
- [[#adding-custom-commands][Adding Custom Commands]]
- [[#comparing-to-cl-loop][Comparing to =cl-loop=]]
- [[#real-world-examples][Real-World Examples]]

* Introduction

  The ~loopy~ macro expands to a ~while~ loop whose context is determined by the
  macro's arguments and whose body is determined by special "loop commands"
  passed in the =loop= macro argument.

  For example, to iterate through the items in a list, one could use the =list=
  loop command.  To collect values into a list, one can use the =collect=
  command.

  #+begin_src emacs-lisp
    ;; => (2 3 4)
    (loopy (with (my-variable 1))
           (loop (list elem '(1 2 3))
                 (collect (+ elem my-variable))))
  #+end_src

  This is very similar to how it would be done with ~cl-loop~:

  #+begin_src emacs-lisp
    (cl-loop with my-var = 1
             for elem in '(1 2 3)
             collect (+ i my-var))
  #+end_src

  Because ~loopy~ uses symbolic expressions instead of clauses like in
  ~cl-loop~, things like conditionally updating variables are much easier.

  #+begin_src emacs-lisp
    (loopy (loop (list i (number-sequence 1 20))
                 (if (cl-evenp i)
                     (set last-even-found i)
                   (collect odds i)))
           (after-do
            (message "Found odds: %s" odds)
            (message "Last even found: %d" last-even-found))
           (finally-return odds))
  #+end_src

  The =loopy= macro has several possible arguments, each beginning with a
  keyword.

  - =with=, =let*= :: Declares and initializes variables that are bound in order
    before and around the loop, like in a =let*= binding.
  - =without=, =no-init= :: Declares variables that ~loopy~ shouldn't try to
    initialize.  Without this, ~loopy~ might set a variable to ~nil~ or ~0~, for
    example.
  - =before-do=, =before= :: A list of normal Lisp expressions to run before the loop
    executes.
  - =loop= :: A list of loop commands, which create the loop body.  These
    commands are described in detail in the section [[file:doc/loopy.org::#loop-commands][Loop Commands]].
  - =after-do=, =after=, =else-do=, =else= :: A list of normal Lisp expressions
    to run after the successful completion of the loop.
  - =finally-do=, =finally= :: A list of normal Lisp expressions that always
    run, regardless of whether an early return was triggered in the loop body.
  - =finally-return=, =return= :: An expression whose value is always returned,
    regardless of whether an early return was triggered in the loop body.  If
    given several expressions, returns their values as one list.
  - =flag=, =flags= :: Optional triggers that change how ~loopy~ behaves.  For
    example, one can use =(flag dash)= to use =dash= for destructuring values
    instead of ~loopy~'s normal behavior.

  The code is expanded so that the loop and any expressions from the =before-do=
  and =after-do= macro arguments are contained in a single ~cl-block~.  Naming
  the loop can be done by passing a symbol as a macro argument, and names this
  block.  This allows for any call to ~cl-return~ (for convenience, already
  wrapped in a =return= loop command) to exit the loop or change the macro's
  return value.  The default return value is ~nil~.

  Loop commands determine when and how the loop exits, and generally follow the
  form =(COMMAND VARIABLE-NAME &rest ARGS)=.  For example,

  - To iterate through a sequence [fn:sequence], use =(seq elem [1 2 3])= (for
    efficiency, there are also more specific commands, like =list=).
  - To collect values into a list, use =(collect my-collection collected-value)=.
  - To just bind a variable to the result of a Lisp expression, use
    =(expr my-var (my-func))=.


  These commands can use destructuring, even accumulation commands.
  #+begin_src emacs-lisp
    ;; = >((1 5) (2 6) (3 7) (4 8))
    (loopy (loop (list [first-half second-half] '([(1 2) (3 4)]
                                                  [(5 6) (7 8)]))
                 (collect (first-quarter second-quarter) first-half)
                 (collect (third-quarter fourth-quarter) second-half)))
  #+end_src

  Other commands create ~setf~-able places.

  #+begin_src emacs-lisp
    ;; => 6, from summing [0 2 0 4]
    (loopy (with (my-array [1 2 3 4]))
           ((array-ref elem my-array)
            (when (cl-oddp elem)
              (do (setf elem 0))))
           (finally-return (cl-reduce #'+ my-array)))

    ;; For completeness, more idiomatic equivalent of above:
    ;; => 6
    (loopy (with (my-array [1 2 3 4]))
           (loop (array elem my-array)
                 (when (cl-evenp elem)
                   (sum elem))))
  #+end_src

  Like in ~cl-loop~, accumulation commands can accumulate into implicit
  variables.  As seen in the above example, we did not need to use =(sum my-sum
  elem)=, as =(sum elem)= automatically initializes a variable adds to it the
  value of =elem=.  The variables used by accumulation commands are
  automatically returned by ~loopy~ without needing an explicit ~return~ usage.
  If multiple accumulation variables are used, they will be returned in a list
  in the order that they appear in the loop body.

  #+begin_src emacs-lisp
    ;; => (("cat" "dog") (2 4 6) (1 3 5))
    (loopy ((list i '(1 2 3 "cat" 4 5 6 "dog"))
            (cond
             ((not (numberp i)) (collect not-numbers i))
             ((cl-evenp i)      (collect evens i))
             (t                 (collect odds i)))))

    ;; More explicitly:
    (loopy ((list i '(1 2 3 "cat" 4 5 6 "dog"))
            (cond
             ((not (numberp i)) (collect not-numbers i))
             ((cl-evenp i)      (collect evens i))
             (t                 (collect odds i))))
           ;; Same as (finally-return (list not-numbers evens odds)):
           (return not-numbers evens odds))
  #+end_src

  Below is an admittedly complicated example of most of the arguments of the
  ~loopy~ macro.  The top-level forms have a flexible-order, but meaning is
  clearest if they have the following order.  All of the arguments are
  technically optional, but passing ~loopy~ no arguments creates an infinite
  ~while~-loop that does nothing.

  #+BEGIN_SRC emacs-lisp
    ;; Returns: '((2 4 6 8 10) (1 3 5 7 9)) and prints messages.
    (loopy
     ;; Name the loop `my-loop'.
     my-loop
     ;; Create the locally scoped variable `success-p', initialized to `nil'.
     (with (success-p nil))
     ;; Before starting the loop, print a message.
     (before-do (message "Beginning loop ..."))
     ;; Create the loop body.
     (loop (list i (number-sequence 1 10))        ; Assign `i' from 1 through 10.
           (do (message "Checking number: %d" i)) ; Report the value of `i'.
           (if (cl-evenp i)                       ; If `i' is even, add to the list
               (collect found-evens i)            ; of even numbers, otherwise add
             (collect found-odds i)))             ; to the list of odd numbers.
     ;; If the loop completes successfully, print a message and update `success-p'.
     (after-do (message "Loop completed successfully.")
               (setq success-p t))
     ;; Always report based on the value of `success-p', and message the value of
     ;; the lists of even and odd numbers.
     (finally-do (if success-p
                     (message "Confirmed success reported.")
                   (message "W: Success not confirmed!"))
                 (message "Found evens: %s" found-evens)
                 (message "Found odds: %s" found-odds))
     ;; Always return a list containing the list of even numbers and the list of odd
     ;; numbers.
     (finally-return (list found-evens found-odds)))
  #+END_SRC

* Similar Libraries
  Loopy is not the only Lisp library that uses expressions instead of keyword
  clauses (like in =cl-loop=).  [[https://common-lisp.net/project/iterate/][=iterate=]] and [[https://github.com/Shinmera/for/][=for=]] are two examples in Common
  Lisp.  I know of no examples for Emacs Lisp.

  Though I am not familiar with either, it seems to me that the =loopy= macro is
  more like =for= than it is like =iterate=.  I suspect that, given it’s youth,
  Loopy is much simpler than both.

  #+begin_src emacs-lisp
    ;; Collecting 10 random numbers:
    ;; cl-loop, iterate, for, loopy

    (cl-loop repeat 10 collect (random 10))

    (iterate (repeat 10) (collect (random 10)))

    (for:for ((i repeat 10) (randoms collecting (random 10))))

    (loopy ((repeat 10) (collect (random 10))))
  #+end_src

  Generally, I’d expect that all of the packages handle basic use cases in
  similar ways.  While =iterate= can apparently embed its looping constructs in
  arbitrary code, =loopy= doesn’t allow that, and I believe that the same is
  true of =for=.

  However, Loopy is not yet feature complete.  Please request features or report
  problems in this project’s [[https://github.com/okamsn/loopy/issues][issues tracker]].  While most things are covered,
  full feature parity with =cl-loop= is still being worked on.

* How to Install                                                   :noexport:
  Currently, Loopy must be installed manually.  Here is how one could use
  ~straight.el~ with ~use-package~

  #+begin_src emacs-lisp
    (use-package loopy
      :straight (loopy :type git :host github :repo "okamsn/loopy"
                       :files (:defaults (:exclude "loopy-dash.el"))))

    ;; Optional support for destructuring with Dash.
    (use-package loopy-dash
      :after (loopy)
      :demand t
      :straight (loopy-dash :type git :host github :repo "okamsn/loopy"
                            :files ("loopy-dash.el")))
  #+end_src

* Destructuring with Dash

  Using =(flag dash)= in ~loopy~ will cause ~loopy~ to use =dash= for
  destructuring.  This applies for normal variables and accumulation, but not
  for ~setf~-able places.

  To enable this, load the file =loopy-dash.el= (found in the same repo as
  =loopy=), such as with

  #+begin_src emacs-lisp
    (use-package loopy-dash
      :after (loopy)
      :straight (loopy-dash :type git :host github :repo "okamsn/loopy"))
  #+end_src

  #+begin_src emacs-lisp
    ;; => (((1 (2 3)) (4 (5 6))) ; whole
    ;;     (1 4)                 ; i
    ;;     (2 5)                 ; j
    ;;     (3 6))                ; k
    (loopy (flag dash)
           (loop (list elem '((1 (2 3)) (4 (5 6))))
                 (collect (whole &as i (j k)) elem)))
  #+end_src

  For more on how ~loopy~ can use =dash=, see the section [[file:doc/loopy-doc.org::*Destructuring with =dash=][Destructuring with =dash=]]
  in the documentation.

  For more on how =dash= does destructuring, see their documentation on the [[https://github.com/magnars/dash.el#-let-varlist-rest-body][-let]]
  form.

* Adding Custom Commands
  :PROPERTIES:
  :CUSTOM_ID: adding-custom-commands
  :END:

   The core working of =loopy= is taking a command and generating code that is
   substituted into or around a loop body.

   For example, parsing the command =(list i '(1 2 3))= produces the following
   list of instructions.  Some commands require the creation of unique temporary
   variables, such as =g3019= in the below output. Such variables are called
   “implicit", as opposed to the explicitly named variable =i= in the command.

   #+BEGIN_SRC emacs-lisp
     ((loopy--implicit-vars g3019 '(1 2 3))
      (loopy--explicit-vars i nil)
      (loopy--pre-conditions consp g3019)
      (loopy--main-body setq i (car g3019))
      (loopy--latter-body setq g3019 (cdr g3019)))
   #+END_SRC

   The ~car~ of an instruction is the place to put code and the ~cdr~ of the
   instruction is said code to put.  You can see that not all of the code to be
   inserted is a valid Lisp form.  Instead of being evaluated as an expression,
   some instructions insert pairs of names and values into variable lists like
   in ~let~ and ~let*~ .

   | Place                     | Code                         |
   |---------------------------+------------------------------|
   | =loopy--implicit-vars=    | =(g3019 '(1 2 3))=           |
   | =loopy--explicit-vars=    | =(i nil)=                    |
   | =loopy--pre-conditions=   | =(consp g3019)=              |
   | =loopy--main-body=        | =(setq i (car g3019))=       |
   | =loopy--latter-body=      | =(setq g3019 (cdr g3019))=   |

   Commands are parsed by =loopy--parse-body-forms=, which receives a list of
   commands and returns a list of instructions.  For commands that take
   sub-commands as arguments (such as =cond=, =if=, and =when=), more specific
   parsing functions are called in a mutually recursive fashion (e.g.,
   Function-1 uses Function-2 which uses Function-1, and so on).

   For example, consider the function =loopy--parse-conditional-forms=, which
   parses the =if=, =when=, and =unless= commands.  It needs to be able to group
   any code going to the loop body under its respective conditional control
   structure.  To do this, it uses =loopy--parse-body-forms= to turn its
   sub-commands into a list of instructions, and then checks the =car= of each
   instruction.

   #+BEGIN_SRC emacs-lisp
     (defun loopy--parse-conditional-forms (wrapper condition forms &optional loop-name)
       "Parse FORMS, wrapping `loopy--main-body' expressions in a conditional form.
     The instructions (e.g., return expressions) are wrapped with a
     WRAPPER with CONDITION.  Optionally needs LOOP-NAME for block
     returns."
       (let ((full-instructions)
             (sub-instructions (loopy--parse-body-forms forms loop-name))
             (conditional-body))
         (dolist (instruction sub-instructions)
           (cl-case (car instruction)
             (loopy--main-body (push (cdr instruction) conditional-body))
             (t                (push instruction full-instructions))))
         (push `(loopy--main-body . (,wrapper ,condition ,@conditional-body))
               full-instructions)
         full-instructions))
   #+END_SRC

   The hardest part of this exchange is making sure the inserted code ends up in
   the correct order.

   A loop body command has 7 main places to put code:

   - =loopy--explicit-generalized-vars= :: Lists of a symbol and a macro
     expansion that will be given to =cl-symbol-macrolet=.  This is used to
     create named ~setf~-able places.  The expansion you use depends on the kind
     of sequence and how the it is updated.

     For example, =(list-ref i my-list)= declares =i= to be a symbol which
     expands to =(car TEMP-VAR)=, in which =TEMP-VAR= holds the value of
     =my-list=.  At the end of the loop body, =TEMP-VAR= is set to its =cdr=,
     ensuring that the next call to =car= returns the correct value.

   - =loopy--implicit-vars= :: Lists of a symbol and an expression that will be
     given to =let=.  This is used for creating variables that are not named but
     must exist, such as for holding ='(1 2 3)= in =(list i '(1 2 3))=.

   - =loopy--explicit-vars= :: Lists of a symbol and an expression that will be
     given to =let=.  This is needed to ensure that variables explicitly named
     in commands are locally scoped, such as the =i= in =(list i '(1 2 3))=.

   - =loopy--pre-conditions= :: Expressions that determine if the =while=
     loop runs/continues, such as whether a list still has elements in it.
     If there is more than one expression, than all expressions are used in
     an =and= special form.

   - =loopy--main-body= :: Expressions that make up the main body of the
     loop.

   - =loopy--latter-body= :: Expressions that need to be run after the main
     body, such as updating implicit variables.

   - =loopy--post-conditions= :: Expressions that determine whether the
     =while= loop continues, but checked after the loop body has run.  The
     code from this is ultimately appended to the latter body before being
     substituted in.

   There are 5 more variables a loop command can push to, but they are derived
   from the macro's arguments.  Adding to them after using a macro argument
   might lead to unintended behavior.  You might wish to use them if, for
   example, you are concerned with what happens after the loop exits/completes.

   - =loopy--with-vars= :: Lists of a symbol and an expression that will be
     given to =let*=.  These are derived from the =with= macro argument.

   - =loopy--before-do= :: Expressions to evaluate before the loop.  These are
     derived from the =before-do= macro argument.

   - =loopy--after-do= :: Expressions to evaluate after the loop completes
     successfully.  These are derived from the =after-do= macro argument.

   - =loopy--final-do= :: Expressions to evaluate after the loop completes,
     regardless of success.  These are derived from the =finally-do= macro
     argument.

   - =loopy--final-return= :: An expression that is always returned by the
     macro, regardless of any early returns in the loop body.  This is
     derived from the =finally-return= macro argument.

   The structure of the macro’s expanded code depends on the features used
   (e.g., =loopy= won’t try to declare variables if none exist), but the result
   will work similar to the below example.

   #+BEGIN_SRC emacs-lisp
     `(cl-symbol-macrolet ,loopy--explicit-generalized-vars
        (let* ,loopy--with-vars
          (let ,(append loopy--implicit-vars loopy--explicit-vars)
            (let ((loopy--early-return-capture
                   (cl-block ,loopy--name-arg
                     ,@loopy--before-do
                     (while ,(cl-case (length loopy--pre-conditions)
                               (0 t)
                               (1 (car loopy--pre-conditions))
                               (t (cons 'and loopy--pre-conditions)))
                       (cl-tagbody
                        ,@loopy--main-body
                        loopy--continue-tag
                        ,@loopy--latter-body))
                     ,@loopy--after-do
                     nil)))
              ,@loopy--final-do
              ,(if loopy--final-return
                   loopy--final-return
                 'loopy--early-return-capture)))))
   #+END_SRC

   For more on custom commands, see the wiki page [[https://github.com/okamsn/loopy/wiki/Custom-Commands][Custom Commands]].

* Comparing to =cl-loop=
  :PROPERTIES:
  :CUSTOM_ID: how-does-it-compare-to-other-approaches
  :END:

  See the wiki page [[https://github.com/okamsn/loopy/wiki/Versus-%60cl-loop%60][Versus =cl-loop=]].


* Real-World Examples

  See the wiki page [[https://github.com/okamsn/loopy/wiki/Examples][Examples]].

# Local Variables:
# org-link-file-path-type: relative
# End:
